#!/system/bin/sh

# Ubuntu rootfs manager
# Copyright (c) 2025 ravindu644

# Made for a replacement for LXC
# Features: Init process logging, automatic shell entry, comprehensive logging

# --- Configuration ---
BASE_ROOTFS_DIR="${BASE_ROOTFS_DIR:-/data/local/ubuntu-rootfs}"
ROOTFS_PATH="${BASE_ROOTFS_DIR}/rootfs"
ROOTFS_IMG="${BASE_ROOTFS_DIR}/rootfs.img"
SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(readlink -f "$0")"
ROOTFS_NAME="Ubuntu"
C_HOSTNAME="ubuntu"
HOLDER_PID_FILE="${BASE_ROOTFS_DIR}/holder.pid"
INIT_LOG_FILE="${BASE_ROOTFS_DIR}/init.log"
SILENT=0

# --- Logging ---
log() { [ "$SILENT" -eq 0 ] && echo "[INFO] $1"; }
warn() { echo "[WARN] $1"; }
error() { echo "[ERROR] $1"; }

# --- Requirements Check ---
check_requirements() {
    local missing_requirements=0

    if [ "$(id -u)" -ne 0 ]; then
        error "Must be run as root"
        error "This is a REQUIRED condition - cannot proceed"
        missing_requirements=$((missing_requirements + 1))
    fi

    if command -v busybox >/dev/null 2>&1; then
        BB="$(which busybox)"
    else
        error "busybox not found"
        error "This is a REQUIRED tool - cannot proceed"
        error "Please install busybox"
        missing_requirements=$((missing_requirements + 1))
    fi

    if ! command -v unshare >/dev/null 2>&1; then
        if [ -z "$BB" ] || ! $BB unshare --help >/dev/null 2>&1; then
            error "unshare command not found"
            error "This is a REQUIRED tool - cannot proceed"
            error "unshare is needed for namespace isolation"
            missing_requirements=$((missing_requirements + 1))
        fi
    fi

    if ! grep -q devtmpfs /proc/filesystems 2>/dev/null; then
        error "devtmpfs is not supported by the kernel"
        error "This is a REQUIRED feature - cannot proceed"
        missing_requirements=$((missing_requirements + 1))
    fi

    if ! grep -q devices /proc/cgroups 2>/dev/null; then
        error "cgroup devices controller is not available"
        error "This is a REQUIRED feature for LXC - cannot proceed"
        missing_requirements=$((missing_requirements + 1))
    fi

    if ! unshare --pid true 2>/dev/null && ! $BB unshare --pid true 2>/dev/null; then
        error "PID namespace is not supported by the kernel"
        error "This is a REQUIRED feature for isolation - cannot proceed"
        missing_requirements=$((missing_requirements + 1))
    fi

    if ! unshare --mount true 2>/dev/null && ! $BB unshare --mount true 2>/dev/null; then
        error "Mount namespace is not supported by the kernel"
        error "This is a REQUIRED feature for isolation - cannot proceed"
        missing_requirements=$((missing_requirements + 1))
    fi

    if [ $missing_requirements -gt 0 ]; then
        error "Missing $missing_requirements required feature(s) - cannot proceed"
        exit 1
    fi
}

# --- Android Optimization ---
android_optimizations() {
    local mode="$1"

    if [ "$mode" = "--enable" ]; then
        log "Android optimizations enabled"
        # Prevent Android from killing the rootfs process
        cmd device_config put activity_manager max_phantom_processes 2147483647 >/dev/null 2>&1
        cmd device_config set_sync_disabled_for_tests persistent >/dev/null 2>&1
        dumpsys deviceidle disable >/dev/null 2>&1
    else
        log "Android optimizations disabled"
        # Revert to defaults
        cmd device_config put activity_manager max_phantom_processes 32 >/dev/null 2>&1
        cmd device_config set_sync_disabled_for_tests none >/dev/null 2>&1
        dumpsys deviceidle enable >/dev/null 2>&1
    fi
}

# -------------------------------------------------------------------------
# INTERNAL BOOT ROUTINE (Runs INSIDE the namespace as PID 1)
# -------------------------------------------------------------------------

internal_boot() {
    # Initialize logging to file
    exec 1>"$INIT_LOG_FILE" 2>&1

    log "Starting init sequence..."

    # 1. Setup Tools
    [ -z "$BB" ] && BB="busybox"
    if ! command -v "$BB" >/dev/null 2>&1; then
        error "Busybox not found in namespace"
        exit 1
    fi

    # Helper for mounting
    domount() {
        local src="$1" tgt="$2" type="$3" opts="$4"
        mkdir -p "$tgt" 2>/dev/null
        if ! $BB mount -t "$type" -o "$opts" "$src" "$tgt" 2>&1; then
            warn "Failed to mount $type at $tgt"
            return 1
        fi
        return 0
    }

    # 2. Mount Propagation
    log "Setting mount propagation..."
    $BB mount --make-rprivate / 2>/dev/null || mount --make-rprivate / 2>/dev/null

    # 3. Prepare Rootfs
    log "Preparing rootfs..."
    if [ -f "$ROOTFS_IMG" ]; then
        mkdir -p "$ROOTFS_PATH"
        if ! $BB mount -t ext4 -o loop,rw,noatime "$ROOTFS_IMG" "$ROOTFS_PATH" 2>&1; then
            error "Failed to mount sparse image"
            exit 1
        fi
        log "Sparse image mounted"
    else
        if [ ! -d "$ROOTFS_PATH" ]; then
            error "Rootfs directory not found: $ROOTFS_PATH"
            exit 1
        fi
        if ! $BB mount --bind "$ROOTFS_PATH" "$ROOTFS_PATH" 2>&1; then
            error "Failed to bind mount rootfs"
            exit 1
        fi
        log "Rootfs bind mounted"
    fi

    # 4. Pivot Root Preparation
    if ! cd "$ROOTFS_PATH"; then
        error "Failed to change directory to $ROOTFS_PATH"
        exit 1
    fi

    mkdir -p .old_root

    # 5. Mount API Filesystems
    log "Mounting essential filesystems..."
    domount proc proc proc "rw,nosuid,nodev,noexec,relatime"

    # 6. Setup Cgroups
    log "Setting up cgroups..."
    # We must remount cgroups inside the namespace
    # Without cgroups, init will fail to start
    $BB mount --make-rslave /
    umount -lf /sys/fs/cgroup 2>/dev/null || true

    domount tmpfs sys/fs/cgroup tmpfs "mode=755,rw,nosuid,nodev,noexec,relatime"
    domount cgroup sys/fs/cgroup/devices cgroup "devices"
    domount cgroup sys/fs/cgroup/systemd cgroup "none,name=systemd"

    # 7. Runtime Environment Configuration
    log "Configuring runtime environment..."
    echo "$C_HOSTNAME" > etc/hostname
    echo "127.0.0.1 localhost $C_HOSTNAME" > etc/hosts
    echo "::1 localhost ip6-localhost ip6-loopback" >> etc/hosts
    $BB hostname "$C_HOSTNAME"

    # DNS setup (Runtime override for DNS)
    mkdir -p run/resolvconf
    echo "nameserver 8.8.8.8" > run/resolvconf/resolv.conf
    echo "nameserver 8.8.4.4" >> run/resolvconf/resolv.conf
    ln -sf /run/resolvconf/resolv.conf etc/resolv.conf

    # Ensure Android network groups exist
    grep -q "aid_inet" etc/group || echo "aid_inet:x:3003:root" >> etc/group
    grep -q "aid_net_raw" etc/group || echo "aid_net_raw:x:3004:root" >> etc/group

    # 8. PIVOT ROOT
    log "Performing pivot_root..."
    if ! $BB pivot_root . .old_root 2>&1; then
        error "Pivot root failed"
        exit 1
    fi

    # 9. Post-pivot cleanup
    export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    export TERM=xterm
    export HOME=/root
    unset LD_PRELOAD

    umount -l /.old_root 2>&1
    rmdir /.old_root 2>/dev/null

    # 9.5. Add root to network groups (if needed at runtime)
    if command -v usermod >/dev/null 2>&1; then
        usermod -a -G aid_inet,aid_net_raw root >/dev/null 2>&1 || true
    fi

    # PAM fix: Disable pam_keyinit.so which can cause issues on older kernels
    find /etc/pam.d/ -type f -exec sed -i -E 's/^(session\s+(optional|required)\s+pam_keyinit\.so)/#\1/' {} + 2>/dev/null || true

    # 10. Handover to Init
    log "Handing over to init..."

    exec /sbin/init

    error "Failed to execute init!"
    exit 1
}

# -------------------------------------------------------------------------
# HOST MANAGER (Runs on Android)
# -------------------------------------------------------------------------

check_status() {
    if [ -f "$HOLDER_PID_FILE" ]; then
        local pid=$(cat "$HOLDER_PID_FILE")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        rm -f "$HOLDER_PID_FILE" "$HOLDER_PID_FILE.flags"
    fi
    return 1
}

# Get nsenter flags from saved flags file
_get_ns_flags() {
    local flags_file="$HOLDER_PID_FILE.flags"
    if [ -f "$flags_file" ]; then
        # Translate long flags to busybox short flags
        local long_flags=$(cat "$flags_file")
        local short_flags=""
        for flag in $long_flags; do
            case "$flag" in
                --mount) short_flags="$short_flags -m" ;;
                --uts)   short_flags="$short_flags -u" ;;
                --ipc)   short_flags="$short_flags -i" ;;
                --pid)   short_flags="$short_flags -p" ;;
            esac
        done
        echo "$short_flags"
    else
        echo "-m -u -p" # Fallback to minimum required flags
    fi
}

# Detect available namespaces and create namespace
create_namespace() {
    local pid_file="$1"
    local unshare_flags=""

    # Check supported namespaces
    for ns_flag in --mount --uts --ipc --pid; do
        if unshare "$ns_flag" true 2>/dev/null || $BB unshare "$ns_flag" true 2>/dev/null; then
            unshare_flags="$unshare_flags $ns_flag"
        fi
    done

    # Save flags to file
    echo "$unshare_flags" > "${pid_file}.flags"

    # Log detected flags
    log "Namespace flags:$unshare_flags"

    return 0
}

# Function to wait for init to complete and display init startup logs
wait_for_init() {
    local timeout=10
    local elapsed=0

    # Wait for log file to be created
    while [ ! -f "$INIT_LOG_FILE" ] && [ $elapsed -lt $timeout ]; do
        sleep 0.2
        elapsed=$((elapsed + 1))
    done

    if [ ! -f "$INIT_LOG_FILE" ]; then
        return 1
    fi

    # Display init logs in real-time until handover
    local lines_shown=0
    local max_wait=30
    elapsed=0

    while [ $elapsed -lt $max_wait ]; do
        if [ -f "$INIT_LOG_FILE" ]; then
            # Show new lines, but only those with [INFO], [WARN], or [ERROR] tags
            local current_lines=$(wc -l < "$INIT_LOG_FILE" 2>/dev/null || echo 0)
            if [ "$current_lines" -gt "$lines_shown" ]; then
                tail -n +$((lines_shown + 1)) "$INIT_LOG_FILE" 2>/dev/null | grep -E "\[(INFO|WARN|ERROR)\]" || true
                lines_shown=$current_lines
            fi

            # Check if init handover completed
            if grep -q "Handing over to /sbin/init" "$INIT_LOG_FILE" 2>/dev/null; then
                # Wait a bit for init to actually start
                sleep 1
                log "Init started!"
                return 0
            fi
        fi
        sleep 0.2
        elapsed=$((elapsed + 1))
    done

    return 0
}

start_rootfs() {
    if check_status; then
        log "Rootfs already running."
        return 0
    fi

    # Check all requirements before proceeding
    check_requirements

    log "Starting $ROOTFS_NAME Rootfs..."

    # Clear old log file
    rm -f "$INIT_LOG_FILE"

    # Apply optimizations
    android_optimizations --enable
    sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1

    # Handle sparse image if it exists
    if [ -f "$ROOTFS_IMG" ]; then
        log "Sparse image detected"
        if mountpoint -q "$ROOTFS_PATH" 2>/dev/null; then
            umount -f "$ROOTFS_PATH" 2>/dev/null || umount -l "$ROOTFS_PATH" 2>/dev/null || true
        fi
        log "Mounting sparse image to rootfs..."
    fi

    # Detect and create namespace
    if ! create_namespace "$HOLDER_PID_FILE"; then
        error "Failed to create namespace"
        return 1
    fi

    # Read detected flags
    local unshare_flags=$(cat "$HOLDER_PID_FILE.flags")

    export BB
    export ROOTFS_PATH
    export ROOTFS_IMG
    export C_HOSTNAME
    export INIT_LOG_FILE

    $BB unshare $unshare_flags --fork \
        "$SCRIPT_PATH" internal_boot &

    local monitor_pid=$!
    local child_pid=""
    local attempts=0

    # Wait for the REAL init process (child of monitor) to spawn
    while [ $attempts -lt 20 ]; do
        if [ -f "/proc/$monitor_pid/task/$monitor_pid/children" ]; then
            child_pid=$(cat "/proc/$monitor_pid/task/$monitor_pid/children" | awk '{print $1}')
        fi

        if [ -z "$child_pid" ]; then
            child_pid=$($BB ps -o pid,ppid | awk -v ppid="$monitor_pid" '$2 == ppid {print $1; exit}')
        fi

        if [ -n "$child_pid" ]; then
            break
        fi
        sleep 0.2
        attempts=$((attempts + 1))
    done

    if [ -z "$child_pid" ]; then
        error "Failed to detect container init PID"
        kill -9 "$monitor_pid" 2>/dev/null
        rm -f "$HOLDER_PID_FILE.flags"
        return 1
    fi

    echo "$child_pid" > "$HOLDER_PID_FILE"
    log "Namespace created (PID: $child_pid)"

    log "Mounting essential filesystems..."
    log "Setting up cgroups for LXC..."

    # Wait for init to complete (logs are written to file)
    wait_for_init

    # Verify init is still running
    sleep 0.5
    if kill -0 "$child_pid" 2>/dev/null; then
        log "Rootfs started successfully."
        return 0
    else
        error "Init process died after startup"
        error "Check logs at: $INIT_LOG_FILE"
        rm -f "$HOLDER_PID_FILE" "$HOLDER_PID_FILE.flags"
        return 1
    fi
}

stop_rootfs() {
    log "Stopping rootfs..."

    if check_status; then
        local pid=$(cat "$HOLDER_PID_FILE")

        # Try to send poweroff signal to init
        log "Sending poweroff signal to init..."
        run_in_rootfs "poweroff" >/dev/null 2>&1 || \
        kill -30 "$pid" 2>/dev/null || kill -15 "$pid" 2>/dev/null

        # Wait for process to terminate
        local timeout=0
        while kill -0 "$pid" 2>/dev/null && [ $timeout -lt 10 ]; do
            sleep 0.5
            timeout=$((timeout + 1))
        done

        # If still alive, force kill
        if kill -0 "$pid" 2>/dev/null; then
            log "Init did not poweroff, sending SIGKILL..."
            kill -9 "$pid" 2>/dev/null
        fi

        rm -f "$HOLDER_PID_FILE" "$HOLDER_PID_FILE.flags"
    fi

    # Unmount sparse image if needed
    if [ -f "$ROOTFS_IMG" ]; then
        mountpoint -q "$ROOTFS_PATH" 2>/dev/null && {
            umount -f "$ROOTFS_PATH" 2>/dev/null || umount -l "$ROOTFS_PATH" 2>/dev/null && log "Sparse image unmounted" || warn "Failed to unmount sparse image"
        }
    fi

    android_optimizations --disable
    log "Stopped."
}

enter_rootfs() {
    local user="${1:-root}"

    if ! check_status; then
        error "Rootfs is not running. Use '$SCRIPT_NAME start' first."
        exit 1
    fi

    local pid=$(cat "$HOLDER_PID_FILE")

    if [ ! -e "/proc/$pid/ns/mnt" ]; then
        error "PID $pid is running but has no namespace entries"
        exit 1
    fi

    log "Entering shell as $user..."

    # Get nsenter flags from saved flags file
    local ns_flags=$(_get_ns_flags)
    local flags="-t $pid $ns_flags"

    # Try entering with test command first
    if ! $BB nsenter $flags -- /usr/bin/env -i true 2>/dev/null; then
        # Fallback to minimum flags if full set fails
        flags="-t $pid -m -u -p"
    fi

    # Build shell command with proper environment
    local common_exports="export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; export TMPDIR='/tmp'; export TERM='xterm'; export HOME='/root';"
    local shell_command

    if [ "$user" = "root" ]; then
        # For root, exec bash directly (we're already root in namespace, no need for su)
        shell_command="$common_exports exec /bin/bash -l"
    else
        # For other users, use su
        shell_command="$common_exports exec /bin/su -l '$user'"
    fi

    # Execute shell using bash
    $BB nsenter $flags -- /bin/bash -c "$shell_command"
}

run_in_rootfs() {
    local cmd="$*"

    if ! check_status; then
        error "Rootfs is not running"
        exit 1
    fi

    local pid=$(cat "$HOLDER_PID_FILE")

    # Get nsenter flags from saved flags file
    local ns_flags=$(_get_ns_flags)
    local flags="-t $pid $ns_flags"

    # Use bash with proper environment
    local common_exports="export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'; export TMPDIR='/tmp';"
    local bash_cmd="$common_exports $cmd"

    $BB nsenter $flags -- /bin/bash -c "$bash_cmd"
}

show_logs() {
    if [ -f "$INIT_LOG_FILE" ]; then
        cat "$INIT_LOG_FILE"
    else
        warn "No init log file found at: $INIT_LOG_FILE"
        return 1
    fi
}

# --- CLI Handling ---
case "$1" in
    internal_boot)
        # This is called internally by unshare
        internal_boot
        ;;
    start)
        if start_rootfs; then
            # Check if running in interactive terminal
            if [ -t 1 ] && [ -t 0 ]; then
                sleep 0.5
                enter_rootfs "${2:-root}"
            fi
        else
            error "Failed to start rootfs"
            exit 1
        fi
        ;;
    stop)
        stop_rootfs
        ;;
    restart)
        log "Restarting rootfs..."
        stop_rootfs
        sleep 1
        if start_rootfs; then
            if [ -t 1 ] && [ -t 0 ]; then
                enter_rootfs "${2:-root}"
            fi
        fi
        ;;
    status)
        if check_status; then
            echo "Status: RUNNING (PID: $(cat "$HOLDER_PID_FILE"))"
        else
            echo "Status: STOPPED"
        fi
        ;;
    enter)
        enter_rootfs "$2"
        ;;
    run)
        shift
        run_in_rootfs "$*"
        ;;
    logs)
        show_logs
        ;;
    *)
        echo "Usage: $SCRIPT_NAME {start|stop|restart|status|enter [user]|run <cmd>|logs}"
        echo ""
        echo "Commands:"
        echo "  start       - Start the rootfs (auto-enters shell if interactive)"
        echo "  stop        - Stop the rootfs"
        echo "  restart     - Restart the rootfs"
        echo "  status      - Show rootfs status"
        echo "  enter       - Enter rootfs shell"
        echo "  run <cmd>   - Run a command in the rootfs"
        echo "  logs        - Display init process logs"
        exit 1
        ;;
esac
